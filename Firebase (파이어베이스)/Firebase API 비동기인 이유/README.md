# Firebase API가 비동기인 이유

- Firebase SDK 팀의 엔지니어들은 API를 일관되고 사용하기 쉽게 만들기 위해 많은 노력을 기울였다.
- 당신이 모바일 클라이언트 SDK에서 알아차렸을 수 있는 한 가지는 데이터 읽기와 쓰기를 다루는 모든 API 호출이 완전히 비동기적이라는 것이다.
- 즉, 결과를 기다리는 코드를 차단하지 않고 호출이 항상 즉시 반환됩니다. 결과는 시간이 좀 지난 후에, 언제든지 준비가 되면 나온다.
- 비동기식 프로그래밍의 중요한 점은 처음에는 직관적이지 않다는 것이다.  
- 데이터를 가져오려면 다음과 같은 구조를 가진 코드를 작성해야 합니다.
```Kotlin
try {
    result = database.get("the_thing_i_want")
    // handle the results here
}
catch (error) {
    // handle any errors here
}
```
- 이것은 동기식이며, 짧고 이해하기 쉽다. `get()`의 결과가 함수에서 직접 반환되고 호출 코드가 완료되기를 기다린다.
- **하지만 이것이 바로 문제이다. 코드를 오랜 시간 기다리게 될 수 있다.**


### 📌 비동기 비유
#### Firebase 비동기 API 방식을 오븐 사용하는 것으로 비유할 수 있다.
- 만약 케이크를 굽고 싶다고, 오븐 앞에서 끝나기를 가만히 기다리지 않을 것이다.
- 아무도 동기식 API처럼 오븐과 상호작용하지 않는다. 대신, 오븐에 타이머를 설정하면, 당신이 가서 다른 일들을 하는 동안 
비동기적으로 당신에게 일이 언제 끝나는지 알려준다. 훨씬 더 효율적으로 일을 할 수 있다.

### 📌 Firebase의 비동기 호출
- `Cloud Firesotre API` 사용한단고 예를 들면,
- 문서를 가져오려면 네트워크 연결 또는 로컬 디스크 캐시가 필요하다. 둘 중 하나의 속도에 대한 보장은 없으며 문서 가져오기 API는 다음과 같이 호출되어야 한다.
```Java
Task<DocumentSnapshot> task =
    FirebaseFirestore.getInstance().document("users/pat").get();
task.addOnSuccessListener(new OnSuccessListener() {
    public void onSuccess(DocumentSnapshot snapshot) {
        // handle the document snapshot here
    }
});
task.addOnFailureListener(new OnFailureListener() {
    public void onFailure(Exception e) {
        // handle any errors here
    }
});
```
- 단순한 동기식 프로토타입에 비해 좀 더 추가적인 코드가 필요하다.


### 📌 비동기 호출을 하는 이유 (동기 API 호출의  단점)
- 비동기 API는 모든 스레드를 관리하며 쓰기가 훨씬 쉽다.
- `Firebase`는 모바일 앱을 위한 동기 API를 제공할 수 있지만, 두가지 부작용을 겪게 될 것이다.
#### 첫번째
- 앱의 메인 스레드에서 동기화 기능을 호출하면 앱이 무기한 동결될 수 있으며, 이는 끔찍한 사용자 경험이다.
- 안드로이드에서는 애플리케이션 응답 없음(ANR) 다이얼로그와 함께 소프트 클래시할 수도 있다.
#### 두번째
- 동기 방식으로 메인 스레드를 차단하지 않으려면 이러한 API를 제대로 호출할 수 있도록 자체 스레드를 관리해야 한다.
- 이것은 훨씬 더 많은 코드가 필요하며, 올바르게 사용하게 어려울 수 있다. 전문 엔지니어도 올바른 스레드 동작에 어려움을 겪는다.

### 📌 비동기 API 장점
#### 첫번째
- API 제공자는 자신을 복제할 수 없는 방식으로 스레드화 동작을 최적화할 수 있다.(API 제공자가 작업의 성능 특성을 이해할 수 있도록 신뢰해야 한다.)
#### 두번째
- 진행 중인 작업의 취소 등 향후 개선의 문을 열어줄 수 있다.

### 📌 메인 스레드를 막는 것이 나쁜 이유
- 사용자 인터페이스가 있는 응용 프로그램 런타임 환경은 일반적으로 `메인 스레드`라고 불리는 단일 스레드를 통해 해당 UI의 모든 상호 작용을 구동한다.
- 당신이 쓰는 대부분의 응용 프로그램 코드는 그 스레드에서 실행될 것이다.
- 스레드는 기본적으로 앱의 프로세스가 끝날 때까지 작업 항목의 대기열을 영원히 순환하는 이벤트 루프에 의해 제어된다.
- 이러한 작업 항목에는 `이벤트 처리`, `화면 렌더링`, `애니메이션` 및 `UI`와 관련된 모든 작업이 포함된다.
- 초당 60프레임의 부드러운 화면 렌더링이 가능하도록 이러한 작업 항목을 충분히 빠르게 순환해야 한다.
- 이는 한 작업 항목이 완료해야 하는 시간이 최대 `16ms`라는 것을 의미한다.
- `16ms`이상일 경우 메인 스레드는 그 작업이 최종적으로 완료될 때까지 당신의 앱에 대한 UI 렌더링을 건너 뙨다. 프레임을 건너뛰는 것은 좋지 않다.
- 따라서, 이벤트 루프에서 이러한 작업 중 하나가 너무 오래 걸리면 대기열에 갇히게 된다. 

### 📌 비동기적으로 생각하기
- Firebase API는 앱의 메인 스레드 성능에 민감하다.  
- 즉, 디스크 또는 네트워크의 데이터를 처리해야 하는 Firebase API 비동기식으로 구현된다.
- 기능이 즉시 되돌아오기 때문에 성능에 대한 걱정 없이 메인 스레드에서 호출할 수 있다. 문서 및 샘플에 설정된 패턴을 사용하여 콜백을 구현하기만 하면 된다.


- 참고
 ```
 - https://medium.com/firebase-developers/why-are-firebase-apis-asynchronous-callbacks-promises-tasks-e037a6654a93
 ```
