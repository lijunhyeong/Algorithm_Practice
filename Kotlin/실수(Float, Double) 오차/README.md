# 실수(Float, Double)타입을 다룰 때 주의해야 할 점

## 📌 컴표터가 실수를 표현하는 방식
- 컴퓨터는 숫자를 표현할 때 기본적으로 `2진수`를 사용한다.
- `13 = 8 + 4 + 1`이므로 해당 자리 숫자를 1로 표현하고 나머지는 0으로 표현하여 `1101`이 된다.
- `0.3` -> `0.01001100110011......(0011)` 무한 반복이다. 이렇게 **2진수로 표현하지 못하는 소수가 발생**하며 컴퓨터에는 표현할 수 있는 가장 근사치의 값이 저장된다.

## 📌 소수점이 포함된 실수를 표현하기
- 컴퓨터는 소수점이 포함된 실수를 표현하기 위해서 `고정 소수점(fixed point)` `부동 소수점(floating point)`를 사용한다.

### 🔍 고정소수점 (fixed point)
- 소수점이 고정되어 있다는 뜻이다.
- 고정 소수점이 `32bit` 크기로 되어있다고 가정하고 2진수로 표현하면
```Text
[ 0 000000000000000 0000000000000000 ] ->[ **부호** **정수** **소수점** ] 
부호 부분(1bit): 부호 결정. 0이면 양수, 1이면 음수  
정수 부분(15bit): 정수 표현  
소수점 부분(16bit): 소수점 이하 자릿수 표현  
```
```Text
`9.6875` 표현
첫번째 부분: 부호를 결정하는데 `9.6875`는 양수이므 `[ 0 ]`
두번째 부분: 정수는 `9`이므로 `[ 000000000001001 ]`  
세번째 부분: 소수점 이하는 `6875`이므로 `[ 1011000000000000 ]`   
이런 식으로 `32bit`가 구성된다.
```
- 정수를 `이진수`로 표현하면 `1은 1` , `10은 2` , `100은 4`, `1000은 8` 자리가 올라갈수록 2를 곱해서 표현한다.
- 소수점 이하는  `1은 1`, `0.1은 0.5`, `0.01은 0.25`, `0.001은 0.125`, `0.0001은 0.0625` 소수점 자리가 내려갈수록 2를 나눠서 표현한다.
- 따라서 소수점 이하 자리 `10110000 00000000`은 `[0.5] + [0.125] + [0.0625]`를 모두 더한 `0.6875`가 된다.  
- 고정 소수점 방식은 정수 부분과 소수 부분의 자릿수가 작아서 표현할 수 있는 범위가 적다는 단점이 있다.

### 🔍 부동소수점 (floating point)
- 소수점이 고정되어 있지 않고 좌우로 움직일 수 있다는 뜻을 말한다.
- 고정 소수점과는 달리 소수점을 자유로이 움직일 수 있어서 **표현할 수 있는 수의 범위가 매우 넓다는 장점**이 있다.
- 부동 소수점을 표현하기 위한 수식 `±(1.가수부)×2^지수부-127`  
```Text
[ 0 00000000 00000000000000000000000 ] ->[ **부호** **지수** **가수부** ] 
부호 부분(1bit): 부호 결정. 0이면 양수, 1이면 음수  
지수 부분(8bit): 지수 표현. 2의 곱을 표현한다. 양수와 음수를 표현해야 하기 때문에 255까지가 아니라 [-127~128]까지 표현할 수 있다.  
가수부 부분(23bit): 가수 표현. 실질적인 숫자. 만약 123,456을 표현한다면 가수는 123456이 된다.
* 가수(假數): 임시로 사용하는 수
```
- 참고로 `10진수로 된 실수의 표준 표기법`은 가장 왼쪽에 있는 숫자에 소수점을 부여하고 진짜 소수점의 위치는 10의 지수를 통해 표현한다. `968.75`의 표준 표기법은 `9.6875 × 10^2`가 된다.  
- 부동소수점을 이용하여 `2진수`로 실수를 나타낼 때도 마찬가지이다. `9.6875`를 부동소수점으로 표현한다면 정수부와 소수부를 나누어서 `1001.1011`이 된다.
- 이를 **표준 표기법**으로 바꾸면 `[1001.1011]` --> `[1.0011011 × 2^3]` 이 된다. 부동 소수점을 적용하면 `[ 0 10000010 00110110000000000000000 ]'
- 원래 `가수부`는 `*1*00110110000000000000000` 맨 앞에 무조건 1이 와야 한다. 하지만 컴퓨터의 가수부에는 무조건 1일테니 기록할 필요를 느끼지 못해 맨 왼쪽에 있는 숫자를 포현하지 않는다.
- `지수부`는 원래는 `00000011` 이어야 하는데 `10000100`이다. 이유는 지수부는 양수와 음수를 둘 다 표현하기 위해서 `8 bit`로 표현할 수 있는 숫자 영역을 반으로 나누어 양수와 음수를 표현한다.
```Text
[ 00000000 ~ 01111110 ] 까지는  -127부터 -1까지인 음수로 표현하고
[ 01111111 ]는 0을 표현
[ 10000000 ~ 11111111 ] 까지는 1부터 128을 표현한다.

따라서 3을 표현하려면 00000011에 127을 더해야 한다.
[00000011]은 -124일 테니 여기에 127인 [01111111]을 더하면
[10000010]인 3이 된다.
```
```Text
다시역으로 정리하자면
[ 0 10000010 00110110000000000000000 ]에서
가수부는 0011011이니
맨 앞에 1 하고 소수점을 추가한 [1.0011011]
그리고 지수부는 3이니 적용을 하면 [1001.1011]
[1001.1011] <- 이것을 10진수로 표현을 하면 
9.6875가 되는 것이다.
```

### ✅ 부동소수점(floating point)과 고정 소수점(fixed point)
- 부동소수점이란 실수를 표현할 때 소수점의 위치를 고정하지 않느 것을 말한다.
- 왜 소수점을 고정하지 않는 것일지는 고정소수점을 보면 알 수 있다.
- `123.456`의 경우 고정소수점에서는 정수 부분 `123`과 소수 부분 `456`을 나눠서 표현한다. 
결국 한정된 비트에 정수와 소수 부분을 분할해 배치할 경우 고정소수점이 나타낼 수 있는 범위가 무척 한정된다.
- 그에 비해, 부동소수점은 `123.456`을 `123456`이라는 유효숫자와 `3`이라는 소수점 위치를 통해서 
고정소수점보다 훨씬 넓은 범위의 수를 표현할 수 있는 장점이 있다.
- 그래서 프로그래밍에서 실수를 표현할 때는 부동소수점을 주로 사용하게 된다. 
사실 계산기만 봐도 왜 부동소수점을 사용하는지를 알 수 있다. 
계산기가 표현할 수 있는 한계(칸)를 넘어설 경우 E(e)가 나오면서 지수 표기법이 나오는 것을 확인할 수 있다. 
여기서 E(e)가 바로 부동소수점, 즉 소수점의 위치를 표시하겠다는 의미다.

### ✅ 정리
- 부동소수점은 아주 작은 수, 아주 큰 수 그리고 무한을 표현하기 위해 도입된 타입이다.
- 표현의 한계로 인해 오차는 값이 커질수록 기하급수적으로 증가한다.
- 이 사실을 기억하면서 정수 계산은 정수 타입에 맡기고, 정밀 계산을 위해서라면 계산 전용 라이브러리를 이용해야한 한다.
- 부동소수점을 사용해야만 한다면 정밀도가 높을수록 좋기 때문에 double을 써야한다.



## 📌 예제
### 예제 코드
```kotlin
fun main() {
    println("1번: ${0.1f + 0.1f + 0.1f}")
    println("2번: ${0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f}")
    println("3번: ${0.1f * 100}")
}
```

### 실행 결과  
```Text
1번: 0.3
2번: 1.0000001
3번: 10.0
```  

### 코드 해설
- 1번: `0.1f`를 3번 더했다. `0.1f`는 `Float형` 실수이다. 예상 결과는 `0.3`이고, 올바르게 출력되었다.
- 2번: `0.1f`를 10번 더했다. 예상과는 달리 `1.0000001`이 출력되었다. 
**그 이유는 소수점을 표현하는 과정에서 2진수로 표현되어 저장되는데 2진수로 저장할 때 소수점이 정확하게 떨어지지 않는 `무한소수`가 되기 때문이다.**  
십진수 0.1은 이진 소수로 정확하게 표현될 수 없다. 0.1로 저장된 이진 근사값의 십진 값을 출력하면 `0.1000000000000000055511151231257827021181583404541015625`가 된다.
때문에 이런 값이 10번 누적되어 연산되니 오차가 발생한 것이다.
- 3번: `0.1f`를 10을 곱했다. 이 경우 연산이 `1번`만 실행되기 때문에 오차도 그만큼 덜 누적된다.

## 📌 액티비티 (Activity)  ✅





