# 실수(Float, Double)타입을 다룰 떄 주의해야 할 점

## 📌 컴표터가 실수를 표현하는 방식
- 컴퓨터는 숫자를 표현할 때 기본적으로 `2진수`를 사용한다.
- `13 = 8 + 4 + 1`이므로 해당 자리 숫자를 1로 표현하고 나머지는 0으로 표현하여 `1101`이 된다.
- `0.3` -> `0.01001100110011......(0011)` 무한 반복이다. 이렇게 **2진수로 표현하지 못하는 소수가 발생**하며 컴퓨터에는 표현할 수 있는 가장 근사치의 값이 저장된다.

## 📌 소수점이 포함된 실수를 표현하기
- 컴퓨터는 소수점이 포함된 실수를 표현하기 위해서 `고정 소수점(fixed point)` `부동 소수점(floating point)`를 사용한다.

### 🔍 고정소수점 (fixed point)
- 소수점이 고정되어 있다는 뜻이다.
- 고정 소수점이 `32bit` 크기로 되어있다고 가정하고 2진수로 표현하면
- [ 0 000000000000000 0000000000000000 ] ->[ **첫번째** **두번쨰** **세번째** ] 
- 첫번째 부분(1bit): 부호 결정. 0이면 양수, 1이면 음수  
두번째 부분(15bit): 정수 표현  
세번째 부분(16bit): 소수점 이하 자릿수 표현  
- `9.6875` 표현
-  첫번째 부분: 부호를 결정하는데 `9.8
두번째 부분: 정수는 `9`이므로 `[ 000000000001001 ]`  
세번째 부분: 소수점 이하는 `6875`이므로 `[ 1011000000000000 ]`   


### 🔍 부동소수점 (floating point)


### ✅ 부동소수점(floating point)과 고정 소수점(fixed point)
- 부동소수점이란 실수를 표현할 때 소수점의 위치를 고정하지 않느 것을 말한다.
- 왜 소수점을 고정하지 않는 것일지는 고정소수점을 보면 알 수 있다.
- `123.456`의 경우 고정소수점에서는 정수 부분 `123`과 소수 부분 `456`을 나눠서 표현한다. 
결국 한정된 비트에 정수와 소수 부분을 분할해 배치할 경우 고정소수점이 나타낼 수 있는 범위가 무척 한정된다.
- 그에 비해, 부동소수점은 `123.456`을 `123456`이라는 유효숫자와 `3`이라는 소수점 위치를 통해서 
고정소수점보다 훨씬 넓은 범위의 수를 표현할 수 있는 장점이 있다.
- 그래서 프로그래밍에서 실수를 표현할 때는 부동소수점을 주로 사용하게 된다. 
사실 계산기만 봐도 왜 부동소수점을 사용하는지를 알 수 있다. 
계산기가 표현할 수 있는 한계(칸)를 넘어설 경우 E(e)가 나오면서 지수 표기법이 나오는 것을 확인할 수 있다. 
여기서 E(e)가 바로 부동소수점, 즉 소수점의 위치를 표시하겠다는 의미다.

### ✅ 정리
- 부동소수점은 아주 작은 수, 아주 큰 수 그리고 무한을 표현하기 위해 도입된 타입이다.
- 표현의 한계로 인해 오차는 값이 커질수록 기하급수적으로 증가한다.
- 이 사실을 기억하면서 정수 계산은 정수 타입에 맡기고, 정밀 계산을 위해서라면 계산 전용 라이브러리를 이용해야한 한다.
- 부동소수점을 사용해야만 한다면 정밀도가 높을수록 좋기 때문에 double을 써야한다.



## 📌 예제
### 예제 코드
```kotlin
fun main() {
    println("1번: ${0.1f + 0.1f + 0.1f}")
    println("2번: ${0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f + 0.1f}")
    println("3번: ${0.1f * 100}")
}
```

### 실행 결과  
```Text
1번: 0.3
2번: 1.0000001
3번: 10.0
```  

### 코드 해설
- 1번: `0.1f`를 3번 더했다. `0.1f`는 `Float형` 실수이다. 예상 결과는 `0.3`이고, 올바르게 출력되었다.
- 2번: `0.1f`를 10번 더했다. 예상과는 달리 `1.0000001`이 출력되었다. 
**그 이유는 소수점을 표현하는 과정에서 2진수로 표현되어 저장되는데 2진수로 저장할 때 소수점이 정확하게 떨어지지 않는 `무한소수`가 되기 때문이다.**  
십진수 0.1은 이진 소수로 정확하게 표현될 수 없다. 0.1로 저장된 이진 근사값의 십진 값을 출력하면 `0.1000000000000000055511151231257827021181583404541015625`가 된다.
때문에 이런 값이 10번 누적되어 연산되니 오차가 발생한 것이다.
- 3번: `0.1f`를 10을 곱했다. 이 경우 연산이 `1번`만 실행되기 때문에 오차도 그만큼 덜 누적된다.

## 📌 액티비티 (Activity)  ✅





